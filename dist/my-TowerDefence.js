/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./enemies.js":
/*!********************!*\
  !*** ./enemies.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Enemy2\": () => (/* binding */ Enemy2)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Enemy2 = /*#__PURE__*/function () {\n  function Enemy2(verticalPosition) {\n    _classCallCheck(this, Enemy2);\n\n    this.x = canvas.width;\n    this.y = verticalPosition - adjust;\n    this.width = cellSize;\n    this.height = cellSize;\n    this.speed = Math.random() * 0.2 + 0.4;\n    this.movement = this.speed;\n    this.health = 100;\n    this.maxHealth = this.health;\n    this.fight = false;\n    this.frameHeight = 299;\n    this.frame = 23;\n  }\n\n  _createClass(Enemy2, [{\n    key: \"update\",\n    value: function update() {\n      this.x -= this.movement;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      ctx.shadowColor = \"red\";\n      ctx.shadowBlur = 10;\n      /* ctx.fillStyle= 'red';\r\n      ctx.fillRect(this.x, this.y, this.width, this.height) */\n\n      this.fight === false ? ctx.drawImage(goblin, 50, this.frame * this.frameHeight, 235, 300, this.x - 20, this.y, 70, 90) : ctx.drawImage(goblin, 50, (this.frame + 20) * this.frameHeight, 265, 300, this.x - 40, this.y, 70, 90); //299\n\n      ctx.fillStyle = 'black';\n      ctx.font = '20px Aldrich';\n      ctx.fillText(Math.floor(this.health), this.x + 10, this.y + 20);\n    }\n  }]);\n\n  return Enemy2;\n}();\n\n//# sourceURL=webpack://towerdefense/./enemies.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enemies_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enemies.js */ \"./enemies.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar canvas = document.getElementById('canvas1');\nvar ctx = canvas.getContext('2d');\ncanvas.width = 1500;\ncanvas.height = 940; //global variables\n\nvar cellSize = 100;\nvar cellGap = 3;\nvar frame = 0;\nvar score = 0;\nvar numberOfResources = 900;\nvar enemiesInterval = 600;\nvar gameOver = false;\nvar winningScore = 50000;\nvar adjust = 100;\nvar cellLimiter = 3;\nvar activeMenuCell = undefined;\nvar gameGrid = [];\nvar headerGrid = [];\nvar defenders = [];\nvar buildings = [];\nvar enemies = [];\nvar projectiles = [];\nvar enemyPosition = [];\nvar resourses = []; //sprites\n\nvar archer = new Image();\narcher.src = 'img/PC_HMM_archer.png';\nvar goblin = new Image();\ngoblin.src = 'img/characters/css_sprites2.png';\nvar building = new Image();\nbuilding.src = 'img/human-city2.png';\nvar coin = new Image();\ncoin.src = 'img/coin_gold.png'; //mouse\n\nvar mouse = {\n  x: undefined,\n  y: undefined,\n  width: 0.1,\n  height: 0.1\n};\nvar canvasPosition = canvas.getBoundingClientRect();\ncanvas.addEventListener('mousemove', function (e) {\n  mouse.x = e.x - canvasPosition.left;\n  mouse.y = e.y - canvasPosition.top;\n});\ncanvas.addEventListener('mouseleave', function () {\n  mouse.x = undefined, mouse.y = undefined;\n}); //game board\n\nvar controlsBar = {\n  width: canvas.width,\n  height: cellSize + 100\n};\n\nvar Cell = /*#__PURE__*/function () {\n  function Cell(x, y, isHead) {\n    _classCallCheck(this, Cell);\n\n    this.x = x;\n    this.y = y;\n    this.width = cellSize;\n    this.height = cellSize;\n    this.type = isHead;\n  }\n\n  _createClass(Cell, [{\n    key: \"draw\",\n    value: function draw() {\n      if (mouse.x && mouse.y && collisian(this, mouse) && !this.type) {\n        ctx.strokeStule = 'black';\n        activeMenuCell === 1 ? ctx.strokeRect(this.x, this.y - 100, this.width, this.height * 2) : ctx.strokeRect(this.x, this.y, this.width, this.height);\n      }\n\n      if (this.type) {\n        ctx.strokeRect(this.x, this.y, this.width, this.height);\n      }\n    }\n  }]);\n\n  return Cell;\n}();\n\nfunction createGrid() {\n  for (var y = controlsBar.height; y < canvas.height; y += cellSize) {\n    for (var x = 0; x < canvas.width; x += cellSize) {\n      if (y < 900 && x < canvas.width - cellLimiter * cellSize) gameGrid.push(new Cell(x, y));\n    }\n  } //header grid\n\n\n  for (var _x = 600; _x < canvas.width; _x += cellSize + 20) {\n    if (_x < canvas.width - cellLimiter * cellSize * 2) headerGrid.push(new Cell(_x, 10, true));\n  }\n}\n\ncreateGrid();\n\nfunction handelGameGrid() {\n  for (var i = 0; i < gameGrid.length; i++) {\n    gameGrid[i].draw();\n  }\n\n  for (var j = 0; j < headerGrid.length; j++) {\n    headerGrid[j].draw();\n  }\n\n  if (activeMenuCell === 0) {\n    ctx.fillStyle = \"rgba(100,150,185,0.5)\";\n    ctx.fillRect(600, 10, 100, 100);\n  }\n\n  if (activeMenuCell === 1) {\n    ctx.fillStyle = \"rgba(100,150,185,0.5)\";\n    ctx.fillRect(720, 10, 100, 100);\n  }\n} //projectiles\n\n\nvar Projectiles = /*#__PURE__*/function () {\n  function Projectiles(x, y) {\n    _classCallCheck(this, Projectiles);\n\n    this.x = x + 50;\n    this.y = y + 50;\n    this.width = 10;\n    this.height = 10;\n    this.power = 20;\n    this.speed = 5;\n  }\n\n  _createClass(Projectiles, [{\n    key: \"update\",\n    value: function update() {\n      this.x += this.speed;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      /* ctx.fillStyle = 'black'\r\n      ctx.beginPath()\r\n      ctx.arc(this.x, this.y, this.width, 0, Math.PI*2)\r\n      ctx.fill() */\n      ctx.drawImage(archer, 690, 125, 70, 5, this.x, this.y - 8, 40, 5);\n    }\n  }]);\n\n  return Projectiles;\n}();\n\nfunction handleProjectiles() {\n  for (var i = 0; i < projectiles.length; i++) {\n    projectiles[i].update();\n    projectiles[i].draw();\n\n    for (var j = 0; j < enemies.length; j++) {\n      if (enemies[j] && projectiles[i] && collisian(enemies[j], projectiles[i])) {\n        enemies[j].health -= projectiles[i].power;\n        projectiles.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (projectiles[i] && projectiles[i].x > canvas.width - cellSize) {\n      projectiles.splice(i, 1);\n      i--;\n    }\n  }\n} //defenders\n\n\nvar Defender = /*#__PURE__*/function () {\n  function Defender(x, y) {\n    _classCallCheck(this, Defender);\n\n    this.x = x;\n    this.y = y - adjust;\n    this.width = cellSize;\n    this.height = cellSize;\n    this.shooting = false;\n    this.health = 100;\n    this.project = [];\n    this.timer = 0;\n    this.frameX = 0;\n    this.frameWidth = 114;\n  }\n\n  _createClass(Defender, [{\n    key: \"draw\",\n    value: function draw() {\n      ctx.shadowBlur = 0;\n      ctx.fillStyle = 'blue'; // ctx.fillRect(this.x, this.y, this.width, this.height)\n      //ctx.drawImage(archer, 300, 15, 100, 140, this.x+40, this.y+27, 60,70);\n\n      !this.shooting ? ctx.drawImage(archer, 0, 60, 80, 140, this.x + 40, this.y + 27, 60, 70) : ctx.drawImage(archer, 180 + this.frameX * this.frameWidth, 15, 90, 140, this.x + 27, this.y + 27, 60, 70);\n      ctx.fillStyle = 'gold';\n      ctx.font = '20px Aldrich';\n      ctx.fillText(Math.floor(this.health), this.x + 25, this.y + 25);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.shooting) {\n        this.timer++;\n\n        if (this.timer % 25 === 0) {\n          this.frameX++;\n          if (this.frameX > 3) this.frameX = 0;\n          if (this.frameX === 2) projectiles.push(new Projectiles(this.x, this.y));\n        }\n        /*  if(this.timer % 100 ===0){\r\n            projectiles.push(new Projectiles(this.x, this.y))\r\n        } */\n\n      } else {\n        this.timer = 0;\n      }\n    }\n  }]);\n\n  return Defender;\n}();\n\ncanvas.addEventListener('click', function (e) {\n  var gridPositionX = mouse.x - mouse.x % cellSize;\n  var gridPositionY = mouse.y - mouse.y % cellSize; //console.log(mouse.x+ 'mouse');\n\n  console.log(gridPositionX + 'GP X');\n  console.log(gridPositionY + 'GP Y'); //if(gridPositionY < cellSize) return;\n\n  var greaterArray = defenders.length >= buildings.length ? defenders.length : buildings.length;\n\n  for (var i = 0; i < greaterArray; i++) {\n    if (defenders[i] && defenders[i].x == gridPositionX && defenders[i].y == gridPositionY) return;\n    if (buildings[i] && buildings[i].x == gridPositionX && (buildings[i].y == gridPositionY || buildings[i].y == gridPositionY - 100)) return;\n  }\n\n  if (activeMenuCell === 0) {\n    // если выбран лучник\n    var defenderCost = 100;\n\n    if (numberOfResources >= defenderCost && mouse.y > cellSize + adjust && mouse.y < 900 && mouse.x < canvas.width - cellLimiter * cellSize) {\n      defenders.push(new Defender(gridPositionX, gridPositionY + 100));\n      numberOfResources -= defenderCost;\n    }\n  }\n\n  if (gridPositionY == 0) {\n    if (gridPositionX == 600) activeMenuCell = 0;\n    if (gridPositionX == 700) activeMenuCell = 1;\n  }\n\n  if (activeMenuCell === 1) {\n    // если выбрано здание \n    for (var _i = 0; _i < greaterArray; _i++) {\n      if (defenders[_i] && defenders[_i].x == gridPositionX && defenders[_i].y == gridPositionY - 100) return; //проверка не стоит ли за зданием лучник\n    }\n\n    var buildingCost = 200;\n\n    if (numberOfResources >= buildingCost && mouse.y > cellSize + adjust && mouse.y < 900 && mouse.x < canvas.width - cellLimiter * cellSize) {\n      buildings.push(new Building(gridPositionX, gridPositionY));\n      numberOfResources -= buildingCost;\n    }\n  }\n});\n\nfunction handleDefenders() {\n  for (var i = 0; i < defenders.length; i++) {\n    defenders[i].draw();\n    defenders[i].update();\n\n    if (enemyPosition.indexOf(defenders[i].y + adjust) !== -1) {\n      defenders[i].shooting = true;\n    } else {\n      defenders[i].shooting = false;\n    }\n\n    for (var j = 0; j < enemies.length; j++) {\n      if (defenders[i] && collisian(defenders[i], enemies[j])) {\n        enemies[j].movement = 0;\n        defenders[i].health -= 0.2;\n        enemies[j].fight = true;\n      }\n\n      if (defenders[i] && defenders[i].health <= 0) {\n        defenders.splice(i, 1);\n        i--;\n        enemies[j].fight = false;\n        enemies[j].movement = enemies[j].speed;\n      }\n    }\n  }\n} //enemies\n\n\nvar Enemy = /*#__PURE__*/function () {\n  function Enemy(verticalPosition) {\n    _classCallCheck(this, Enemy);\n\n    this.x = canvas.width;\n    this.y = verticalPosition - adjust;\n    this.width = cellSize;\n    this.height = cellSize;\n    this.speed = Math.random() * 0.2 + 0.4;\n    this.movement = this.speed;\n    this.health = 100;\n    this.maxHealth = this.health;\n    this.fight = false;\n    this.frameHeight = 299;\n    this.frame = 23;\n  }\n\n  _createClass(Enemy, [{\n    key: \"update\",\n    value: function update() {\n      this.x -= this.movement;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      ctx.shadowColor = \"red\";\n      ctx.shadowBlur = 10;\n      /* ctx.fillStyle= 'red';\r\n      ctx.fillRect(this.x, this.y, this.width, this.height) */\n\n      this.fight === false ? ctx.drawImage(goblin, 50, this.frame * this.frameHeight, 235, 300, this.x - 20, this.y, 70, 90) : ctx.drawImage(goblin, 50, (this.frame + 20) * this.frameHeight, 265, 300, this.x - 40, this.y, 70, 90); //299\n\n      ctx.fillStyle = 'black';\n      ctx.font = '20px Aldrich';\n      ctx.fillText(Math.floor(this.health), this.x + 10, this.y + 20);\n    }\n  }]);\n\n  return Enemy;\n}();\n\nfunction handleEnimies() {\n  for (var i = 0; i < enemies.length; i++) {\n    enemies[i].update();\n    enemies[i].draw();\n    enemies[i].frame++;\n    if (enemies[i].frame === 41) enemies[i].frame = 23;\n\n    if (enemies[i] && enemies[i].health <= 0) {\n      var gainedResources = enemies[i].maxHealth / 5;\n      numberOfResources += gainedResources;\n      score += gainedResources;\n      var findThisPosition = enemyPosition.indexOf(enemies[i].y + adjust);\n      enemyPosition.splice(findThisPosition, 1);\n      enemies.splice(i, 1);\n      i--;\n    }\n\n    if (enemies[i] && enemies[i].x < 0) {\n      gameOver = true;\n    }\n  }\n\n  if (frame % enemiesInterval === 0) {\n    var verticalPosition = Math.floor(Math.random() * 5 + 1) * cellSize + 200;\n    console.log(verticalPosition);\n    enemies.push(new Enemy(verticalPosition));\n    enemyPosition.push(verticalPosition);\n    if (enemiesInterval > 120) enemiesInterval -= 20;\n  }\n} //resources\n\n\nvar amounts = [20, 30, 40];\n\nvar Resource = /*#__PURE__*/function () {\n  function Resource() {\n    _classCallCheck(this, Resource);\n\n    /* this.x = Math.random() * canvas.width-cellSize\r\n    this.y = (Math.floor(Math.random() * 6)+1)*cellSize+200 */\n    this.buildingIndex = Math.floor(Math.random() * buildings.length);\n    this.x = buildings[this.buildingIndex].x + 35;\n    this.y = buildings[this.buildingIndex].y + 10;\n    this.width = cellSize * 0.5;\n    this.height = cellSize * 0.5;\n    this.amount = amounts[Math.floor(Math.random() * amounts.length)];\n    this.frame = 0;\n    this.frameWidth = 32;\n  }\n\n  _createClass(Resource, [{\n    key: \"draw\",\n    value: function draw() {\n      ctx.shadowBlur = 0;\n      /* ctx.fillStyle = 'yellow'\r\n      ctx.fillRect(this.x, this.y, this.width, this.height) */\n\n      if (frame % 9 === 0 && score < winningScore) {\n        this.frame++;\n        if (this.frame > 7) this.frame = 0;\n      }\n\n      ctx.drawImage(coin, this.frame * this.frameWidth, 0, 30, 32, this.x + 8, this.y + 13, 40, 42);\n      ctx.fillStyle = 'black';\n      ctx.font = '20px Aldrich';\n      ctx.shadowBlur = 20;\n      ctx.fillStyle = 'yellow';\n      ctx.fillText(this.amount, this.x + 15, this.y + 10);\n    }\n  }]);\n\n  return Resource;\n}();\n\nfunction handleResources() {\n  if (buildings.length > 0 && frame % (500 / buildings.length) === 0 && score < winningScore) {\n    resourses.push(new Resource());\n  }\n\n  for (var i = 0; i < resourses.length; i++) {\n    resourses[i].draw();\n\n    if (resourses[i] && mouse.x && mouse.y && collisian(resourses[i], mouse)) {\n      numberOfResources += resourses[i].amount;\n      resourses.splice(i, 1);\n      i--;\n    }\n  }\n} //utiltties\n\n\nfunction handelGameStatus() {\n  ctx.shadowColor = \"white\"; //ctx.shadowBlur = 20;\n\n  ctx.shadowBlur = 20;\n  ctx.fillStyle = 'black';\n  ctx.font = '50px Aldrich';\n  ctx.fillText('Score: ' + score, 1220, 80);\n  ctx.fillText('Resources: ' + numberOfResources, 20, 80);\n\n  if (gameOver) {\n    ctx.fillStyle = 'black';\n    ctx.font = '80px Aldrich';\n    ctx.fillText('GAME OVER', 300, 330);\n  }\n\n  if (score >= winningScore && enemies.length === 0) {\n    ctx.fillStyle = 'black';\n    ctx.font = '80px Aldrich';\n    ctx.fillText('You are winner!');\n  }\n}\n\nfunction animate() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height); //ctx.fillStyle='rgb(250, 177, 67)'\n  //ctx.fillRect(0,0,controlsBar.width, controlsBar.height)\n\n  handleBuildings();\n  handelGameGrid();\n  handleDefenders();\n  handleEnimies();\n  handleProjectiles();\n  handelGameStatus();\n  handleResources();\n  header();\n  if (!gameOver) requestAnimationFrame(animate);\n  frame++;\n}\n\nanimate();\n\nfunction collisian(first, second) {\n  if (first && second) {\n    if (!(first.x > second.x + second.width || first.x + first.width < second.x || first.y + 4 > second.y + second.height || first.y + first.height < second.y + 4)) {\n      return true;\n    }\n  }\n}\n\nfunction header() {\n  ctx.drawImage(archer, 0, 60, 80, 140, 620, 30, 60, 70);\n  ctx.drawImage(building, 0, 0, 80, 140, 720, 20, 110, 150);\n}\n\nwindow.addEventListener('resize', function () {\n  canvasPosition = canvas.getBoundingClientRect();\n}); //buildings\n\nvar Building = /*#__PURE__*/function () {\n  function Building(x, y) {\n    _classCallCheck(this, Building);\n\n    this.x = x;\n    this.y = y - adjust;\n    this.width = cellSize;\n    this.height = cellSize * 2;\n    this.health = 100;\n    this.timer = 0;\n  }\n\n  _createClass(Building, [{\n    key: \"draw\",\n    value: function draw() {\n      ctx.shadowBlur = 0;\n      ctx.drawImage(building, 0, 0, 80, 140, this.x - 40, this.y + 30, 170, 330);\n      ctx.fillStyle = 'black';\n      ctx.font = '20px Aldrich';\n      ctx.fillText(Math.floor(this.health), this.x, this.y + 40);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      /*  if(this.timer % 100 ===0){\r\n              projectiles.push(new Projectiles(this.x, this.y))\r\n          } */\n    }\n  }]);\n\n  return Building;\n}();\n\nfunction handleBuildings() {\n  for (var i = 0; i < buildings.length; i++) {\n    buildings[i].draw();\n\n    for (var j = 0; j < enemies.length; j++) {\n      if (buildings[i] && collisian(buildings[i], enemies[j])) {\n        enemies[j].movement = 0;\n        buildings[i].health -= 0.2;\n        enemies[j].fight = true;\n      }\n\n      if (buildings[i] && buildings[i].health <= 0) {\n        buildings.splice(i, 1);\n        i--;\n        enemies[j].fight = false;\n        enemies[j].movement = enemies[j].speed;\n      }\n    }\n  }\n} //отменяем дефолтное поведение мышки(райтклик)\n\n\ndocument.oncontextmenu = rightClick;\n\nfunction rightClick(clickEvent) {\n  clickEvent.preventDefault();\n  activeMenuCell = undefined;\n}\n\n//# sourceURL=webpack://towerdefense/./index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;